//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { NswagBaseClass } from '../nswag/nswag-base-class'
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class BookingsService extends NswagBaseClass {
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) configuration: HttpClient, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl;
    }

    /**
     * Create a new booking for the current user.
     * @return Success
     */
    createBooking(body: CreateBookingRequestDto): Observable<CreateBookingReplyDto> {
        let url_ = this.baseUrl + "/api/bookings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.processRequest("post", url_, options_, false);
    }

    /**
     * Delete an existing booking.
     * @return Success
     */
    deleteBooking(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/bookings?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
            })
        };

        return this.processRequest("delete", url_, options_, false);
    }

    /**
     * Return the list of future bookings for the current user.
     * @return Success
     */
    getFutureBookings(): Observable<BookingDto[]> {
        let url_ = this.baseUrl + "/api/bookings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.processRequest("get", url_, options_, false);
    }

    /**
     * Return the requested booking or null.
     * @return Success
     */
    getBookingById(id: string): Observable<BookingDto> {
        let url_ = this.baseUrl + "/api/bookings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.processRequest("get", url_, options_, false);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IdentityService extends NswagBaseClass {
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) configuration: HttpClient, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl;
    }

    /**
     * Try to authenticate the given user.
     * @param body The user to authenticate.
     * @return Success
     */
    authenticate(body: LoginRequestDto): Observable<LoginResponseDto> {
        let url_ = this.baseUrl + "/api/identity/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.processRequest("post", url_, options_, false);
    }

    /**
     * Create a new user in the system with the default role.
     * @param body The user to create.
     * @return Success
     */
    registerUser(body: RegisterRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/identity/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.processRequest("post", url_, options_, false);
    }

    /**
     * Send the password reset link.
     * @return Success
     */
    sendPasswordResetLink(email: string): Observable<void> {
        let url_ = this.baseUrl + "/api/identity/send-password-reset-link?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
            })
        };

        return this.processRequest("post", url_, options_, false);
    }

    /**
     * Reset the password using the reset link.
     * @return Success
     */
    resetPassword(body: ResetPasswordRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/identity/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.processRequest("post", url_, options_, false);
    }

    /**
     * Return the list af all users with athe 'Admin' role.
     * @return Success
     */
    getAllAdmins(): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/identity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.processRequest("get", url_, options_, false);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RecurringSchedulesService extends NswagBaseClass {
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) configuration: HttpClient, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl;
    }

    /**
     * Create a new recurring schedule.
     * @return Success
     */
    createRecurringSchedule(body: CreateRecurringScheduleRequestDto): Observable<CreateScheduleReplyDto> {
        let url_ = this.baseUrl + "/api/schedules/recurring";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.processRequest("post", url_, options_, false);
    }

    /**
     * Returns the list of all returning schedules and their next executions.
     * @return Success
     */
    getAllRecurring(): Observable<RecurringScheduleDto[]> {
        let url_ = this.baseUrl + "/api/schedules/recurring";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.processRequest("get", url_, options_, false);
    }

    /**
     * Update an existing recurring schedule instance.
     * @return Success
     */
    updateRecurringSchedule(body: UpdateRecurringScheduleRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/schedules/recurring";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.processRequest("put", url_, options_, false);
    }

    /**
     * Delete an existing recurring schedule.
     * @return Success
     */
    deleteRecurringSchedule(id: string, body: DeleteRecurringScheduleRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/schedules/recurring/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.processRequest("delete", url_, options_, false);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchedulesService extends NswagBaseClass {
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) configuration: HttpClient, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl;
    }

    /**
     * Generate all (single and recurring) schedules that are in the given interval.
     * @return Success
     */
    getAllSchedulesInRange(startDate: string, endDate: string): Observable<GeneratedScheduleDto[]> {
        let url_ = this.baseUrl + "/api/schedules?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.processRequest("get", url_, options_, false);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SingleSchedulesService extends NswagBaseClass {
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) configuration: HttpClient, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl;
    }

    /**
     * Create a new single schedule.
     * @return Success
     */
    createSingleSchedule(body: CreateSingleScheduleRequestDto): Observable<CreateScheduleReplyDto> {
        let url_ = this.baseUrl + "/api/schedules/single";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.processRequest("post", url_, options_, false);
    }

    /**
     * Update an existing single schedule.
     * @return Success
     */
    updateSingleSchedule(body: UpdateSingleScheduleRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/schedules/single";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.processRequest("put", url_, options_, false);
    }

    /**
     * Delete an existing schedule.
     * @return Success
     */
    deleteSingleSchedule(id: string, body: DeleteSingleScheduleRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/schedules/single/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "json",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.processRequest("delete", url_, options_, false);
    }
}

export interface BookingDto {
    id?: string;
    schedule?: BookingDto_ScheduleDto | null;
    startDate?: string;
    endDate?: string;
    user?: BookingDto_UserDto | null;
}

export interface BookingDto_ScheduleDto {
    id?: string;
    name?: string | null;
    description?: string | null;
    organizerFullName?: string | null;
    durationInMinutes?: number;
}

export interface BookingDto_UserDto {
    id?: string;
    fullName?: string | null;
}

export interface CreateBookingReplyDto {
    id: string;
    currentParticipantsNumber: number;
}

export interface CreateBookingRequestDto {
    scheduleId: string;
    startDate: string;
    endDate: string;
}

export interface CreateRecurringScheduleRequestDto {
    name: string;
    description: string;
    startDate: string;
    durationInMinutes: number;
    endDate: string;
    recurringCronExpression: string;
    participantsMaxNumber: number;
    organizerId: string;
}

export interface CreateScheduleReplyDto {
    id: string;
}

export interface CreateSingleScheduleRequestDto {
    name: string;
    description: string;
    startDate: string;
    durationInMinutes: number;
    /** Defaults to zero if no limit is required. */
    participantsMaxNumber: number;
    /** The id of the organizer of this schedule. */
    organizerId: string;
}

export interface DeleteRecurringScheduleRequestDto {
    id: string;
    /** Describe how to handle operations on recurring schedules. */
    recurringScheduleOperationType: RecurringScheduleOperationType;
    instanceStartDate: string;
    instanceEndDate: string;
}

export interface DeleteSingleScheduleRequestDto {
    id: string;
}

/** Every exception will be serialized to the client wrapped in this class. */
export interface ExceptionDto {
    message: string;
}

export interface GeneratedScheduleDto {
    scheduleId: string;
    organizer: GeneratedScheduleDto_UserDto;
    startDate: string;
    endDate: string;
    readonly durationInMinutes: number;
    name: string;
    description: string;
    bookings: GeneratedScheduleDto_BookingDto[];
    participantsMaxNumber: number;
    isRecurring: boolean;
    recurringCronExpression?: string | null;
}

export interface GeneratedScheduleDto_BookingDto {
    id: string;
    /** Populated only if the caller is admin. */
    user?: GeneratedScheduleDto_UserDto | null;
}

export interface GeneratedScheduleDto_UserDto {
    id: string;
    email: string;
    userName: string;
    fullName: string;
}

/** The login request dto. */
export interface LoginRequestDto {
    /** The user name or email. */
    userNameOrEmail: string;
    /** The user password. */
    password: string;
}

/** The response for the login. */
export interface LoginResponseDto {
    /** The granted Bearer token or null if authentication fails. */
    accessToken: string;
    user: UserDto;
}

export interface RecurringScheduleDto {
    id: string;
    organizer: RecurringScheduleDto_UserDto;
    startDate: string;
    endDate?: string | null;
    durationInMinutes: number;
    name: string;
    description: string;
    participantsMaxNumber: number;
    recurringCronExpression: string;
    nextOccurrences: string[];
}

export interface RecurringScheduleDto_UserDto {
    id: string;
    email: string;
    userName: string;
    fullName: string;
}

/** Describe how to handle operations on recurring schedules. */
export enum RecurringScheduleOperationType {
    Instance = "Instance",
    InstanceAndFuture = "InstanceAndFuture",
}

/** The DTO for creating a new user. */
export interface RegisterRequestDto {
    /** The email address. */
    email: string;
    /** The user name (not email). */
    userName: string;
    /** The first and last name. */
    fullName: string;
    /** The user password. */
    password: string;
}

export interface ResetPasswordRequestDto {
    email: string;
    newPassword: string;
    resetToken: string;
}

export interface UpdateRecurringScheduleRequestDto {
    id: string;
    name: string;
    description: string;
    instanceStartDate: string;
    instanceEndDate: string;
    startDate: string;
    endDate: string;
    durationInMinutes: number;
    participantsMaxNumber: number;
    recurringCronExpression: string;
    organizerId: string;
    /** Describe how to handle operations on recurring schedules. */
    recurringScheduleOperationType: RecurringScheduleOperationType;
}

export interface UpdateSingleScheduleRequestDto {
    id: string;
    name: string;
    description: string;
    startDate: string;
    durationInMinutes: number;
    participantsMaxNumber: number;
    organizerId: string;
}

export interface UserDto {
    email: string;
    id: string;
    userName: string;
    fullName: string;
    roles: string[];
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}